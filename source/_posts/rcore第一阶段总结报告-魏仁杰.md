---
title: rcore第一阶段总结报告-魏仁杰
date: 2022-08-01 04:56:49
categories:
	- report
tags:
	- author:weirenjie
	- summerofcode2022
	- rustsbi
---
# rust语言学习

* Rust 语言是一种面向系统（包括操作系统）开发的语言
* Rust语言的安全性让人印象深刻
* Rust语言对于硬件的支持的库内容非常丰富和完善
* Rust语言能够编程更灵活，能够兼顾各种编程思想
* Rust拥有许多便于操作的特性

# rcore

实验一 使我对操作系统的本质有了一定的认识，同时了解了qemu和真实计算机的启动流程，程序的内存布局和编译过程。
* 将PC寄存器设置为ROM物理地址,运行ROM固件初始化，将bootloader的代码和数据从硬盘载入物理内存中，跳转到bootloader
* 由bootloader加载至物理起始地址0x80000000，进行CPU初始化，并负责将操作系统从硬盘载入物理内存
* 跳转至操作系统，操作系统开始一系列工作


# 实验二 使我理解了特权级机制的主要目的，如何实现和具体特性，以及批处理系统的内容

* 保护操作系统不受有意或无意出错的程序破坏的机制被称为 特权级 (Privilege) 机制，它实现了用户态和内核态的隔离，需要软件和硬件的共同努力。
    * 设置特全集的主要目的是由于应用程序运行的安全性不可充分信任，从而对软件设置了一定的条件
    * 一方面要对应用程序作出一定的限制，另一方面能得到操作系统的服务。即应用程序和操作系统还需要有交互的手段。使得低特权级软件都只能做高特权级软件允许它做的，且低特权级软件的超出其能力的要求必须寻求高特权级软件的帮助。
    * 处理器在执行一条指令前回进行特权级安全检查
    * ecall ：具有用户态到内核态的执行环境切换能力的函数调用指令
    * eret ：具有内核态到用户态的执行环境切换能力的函数返回指令（RISC-V中有类似的 sret 指令）
    * 每个特权级都对应一些特殊指令和 控制状态寄存器 (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态
    * RISC-V特权级中，只有M特权级是必须实现的
    * 在 Trap 前的特权级不会高于Trap后的特权级


# 实验三 让我明白了多道程序和分时处理系统的核心和具体实现

* 能够一次性加载所有用户程序，减少任务切换的开销
* 支持任务切换机制，保存切换前后程序上下文
* 支持程序主动放弃处理器，实现yield系统调用
* 以时间片转轮算法调度用户程序，实现资源的时分复用
* 抢占式操作系统是任务随时都有可能被切换出去
* 应用程序的一次执行过程称为一个任务
* 任务切换时来自两个不同应用在内核中的Trap控制流之间的切换
* _switch函数的核心是能够进行换栈，变换sp地址到任务上下文
* 内核栈用于保存应用执行状态的Trap上下文，内核在对Trap处理时留下的调用栈信息，以及一些寄存器信息。
* 在内存中尽量同时驻留多个应用，但只有一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序。这种运行方式称为多道程序
* 多个应用程序被一次性地加载到内存中，这样在切换到另外一个应用程序执行会很快，不需清空前一个应用，然后加载当前应用的过程与开销。
* 任务切换不涉及特权级切换，它的一部分工作是由编译器帮忙完成的，它对应用是透明的。事实上，它是来自两个不同应用的 Trap 执行流之间的切换。当一个应用 Trap 到 S 模式的操作系统中进行进一步处理的时候，其 Trap 执行流可以调用一个特殊的 switch 函数。这个函数表面上就是一个普通的函数调用：在 switch 返回之后，将继续从调用该函数的位置继续向下执行。但是其间却隐藏着复杂的执行流切换过程。具体来说，调用 switch 之后直到它返回前的这段时间，原 Trap 执行流会先被暂停并被切换出去， CPU 转而运行另一个应用的 Trap 执行流。之后在时机合适的时候，原 Trap 执行流才会从某一条 Trap 执行流（很有可能不是它之前切换到的那一条）切换回来继续执行并最终返回。不过，从实现的角度讲， switch 和一个普通的函数之间的差别仅仅是它会换栈
* 对于某个处理器核而言， 陷入与发起 陷入 的指令执行是 同步 (Synchronous) 的，陷入被触发的原因一定能够追溯到某条指令的执行；而中断则 异步 (Asynchronous) 于当前正在进行的指令，也就是说中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关。

# 实验四 使我对虚拟内存的内容和机制有了更加深入的了解，对抽象的使用有了更好的认识

* 通过动态内存分配，提高应用对内存的使用效率，同时通过虚实内存映射机制，简化编译器对应用的地址空间设置，加强了内存隔离，避免了应用直接访问物理内存
* 通过限制应用最大可用内存小于物理内存的容量，从而使多个应用的数据驻留。
* 要完成并完善地址空间设计，仍需要来自计算机硬件的支持，例如MMU 和 TLB 等硬件机制。
* 完成虚实地址转换，需要硬件提供一些寄存器，让软件可以对他进行设置，来控制MMV按照某个应用的地址关系进行地址转换
* 分页式内存管理内核以也为单位进行物理内存管理，每个应用的地址空间被分成若干个虚拟页面，而物理内存也相类似地分成若干个页帧，虚拟页面和物理页帧的大小相同
* 当一个应用的地址空间比较大的时候，页表里面的项数会很多，以至于它的容量极速膨胀，CPU 内也没有 足够的硬件资源能够将它存下来。因此它只能作为一种被内核管理的数据结构放在内存中，但是 CPU 也会直接访问它来查页表， 这就需要内核和硬件之间关于页表的内存布局达成一致
* 在分配页地时候返回值类型并不是 FrameAllocator 要求的物理页号 PhysPageNum ，而是将其 进一步包装为一个 FrameTracker 。这里借用了 RAII 的思想，将一个物理页帧的生命周期绑定到一个 FrameTracker 变量上，只需为 FrameTracker 实现 Drop Trait，当一个 FrameTracker 实例被回收的时候，它的 drop 方法会自动被编译器调用，通过之前实现的 frame_dealloc 我们就将它控制的物理页帧回收以供后续使用了

#实验五 使我对进程的概念和相关的系统调用有了更深入的了解和认识

* 进程是在操作系统管理下程序的一次执行过程
* 可执行文件相当于指导硬件进行一轮生产的蓝图，而内核能够按照蓝图上对资源的需求对硬件资源进行分配，同时在生产结束之后对硬件资源进行回收
* 重要的系统调用有fork，waitpid，exec等，fork和exec的组合能够实现创建一个其他的特定的子进程
* Fork调用中，原进程返回值为它新创建进程的PID，而新进程的返回值为始终为0。
* 线程是进程的一部分，一个进程可以包含多个线程，线程拥有自己独立的栈和控制流，线程是处理器调度和分派的基本单位，协程（纤程）是程序执行中的一个单一的顺序控制流程，建立在线程之上，一个线程可以包含多个协程。
* 之所以创建进程设计成使用两个系统调用的原因是节省开销，可以灵活地支持重定向等功能。

